!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var s=t();for(var n in s)("object"==typeof exports?exports:e)[n]=s[n]}}(self,(()=>(()=>{"use strict";var e,t,s={22:e=>{e.exports=require("@journeyapps/wa-sqlite/dist/mc-wa-sqlite.mjs")},710:e=>{e.exports=require("@journeyapps/wa-sqlite/src/examples/AccessHandlePoolVFS.js")},895:e=>{e.exports=require("@journeyapps/wa-sqlite/dist/mc-wa-sqlite-async.mjs")},914:e=>{e.exports=require("@journeyapps/wa-sqlite/dist/wa-sqlite-async.mjs")},950:e=>{e.exports=require("@journeyapps/wa-sqlite/src/examples/OPFSCoopSyncVFS.js")},954:e=>{e.exports=require("@journeyapps/wa-sqlite/src/examples/IDBBatchAtomicVFS.js")},971:e=>{e.exports=require("@journeyapps/wa-sqlite/dist/wa-sqlite.mjs")}},n={};function o(e){var t=n[e];if(void 0!==t)return t.exports;var i=n[e]={exports:{}};return s[e](i,i.exports,o),i.exports}t=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__,o.t=function(s,n){if(1&n&&(s=this(s)),8&n)return s;if("object"==typeof s&&s){if(4&n&&s.__esModule)return s;if(16&n&&"function"==typeof s.then)return s}var i=Object.create(null);o.r(i);var a={};e=e||[null,t({}),t([]),t(t)];for(var r=2&n&&s;"object"==typeof r&&!~e.indexOf(r);r=t(r))Object.getOwnPropertyNames(r).forEach((e=>a[e]=()=>s[e]));return a.default=()=>s,o.d(i,a),i},o.d=(e,t)=>{for(var s in t)o.o(t,s)&&!o.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:t[s]})},o.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),o.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};const i=require("@journeyapps/wa-sqlite"),a=require("comlink"),r=require("@powersync/common"),c=require("async-mutex");var l;!function(e){e.IDBBatchAtomicVFS="IDBBatchAtomicVFS",e.OPFSCoopSyncVFS="OPFSCoopSyncVFS",e.AccessHandlePoolVFS="AccessHandlePoolVFS"}(l||(l={}));const u=async()=>{const{default:e}=await Promise.resolve().then(o.t.bind(o,971,23));return e()},d=async()=>{const{default:e}=await Promise.resolve().then(o.t.bind(o,22,23));return e()},p={[l.IDBBatchAtomicVFS]:async e=>{let t;t=e.encryptionKey?await(async()=>{const{default:e}=await Promise.resolve().then(o.t.bind(o,895,23));return e()})():await(async()=>{const{default:e}=await Promise.resolve().then(o.t.bind(o,914,23));return e()})();const{IDBBatchAtomicVFS:s}=await Promise.resolve().then(o.t.bind(o,954,23));return{module:t,vfs:await s.create(e.dbFileName,t,{lockPolicy:"exclusive"})}},[l.AccessHandlePoolVFS]:async e=>{let t;t=e.encryptionKey?await d():await u();const{AccessHandlePoolVFS:s}=await Promise.resolve().then(o.t.bind(o,710,23));return{module:t,vfs:await s.create(e.dbFileName,t)}},[l.OPFSCoopSyncVFS]:async e=>{let t;t=e.encryptionKey?await d():await u();const{OPFSCoopSyncVFS:s}=await Promise.resolve().then(o.t.bind(o,950,23));return{module:t,vfs:await s.create(e.dbFileName,t)}}};class h extends r.BaseObserver{options;_sqliteAPI=null;_dbP=null;_moduleFactory;updatedTables;updateTimer;statementMutex;broadcastChannel;connectionId;constructor(e){super(),this.options=e,this.updatedTables=new Set,this.updateTimer=null,this.broadcastChannel=null,this.connectionId=(new Date).valueOf()+Math.random(),this.statementMutex=new c.Mutex,this._moduleFactory=p[this.options.vfs]}get sqliteAPI(){if(!this._sqliteAPI)throw new Error("Initialization has not completed");return this._sqliteAPI}get dbP(){if(!this._dbP)throw new Error("Initialization has not completed");return this._dbP}async openDB(){return this._dbP=await this.sqliteAPI.open_v2(this.options.dbFilename),this._dbP}async executeEncryptionPragma(){this.options.encryptionKey&&await this.executeSingleStatement(`PRAGMA key = "${this.options.encryptionKey}"`)}async openSQLiteAPI(){const{module:e,vfs:t}=await this._moduleFactory({dbFileName:this.options.dbFilename,encryptionKey:this.options.encryptionKey}),s=i.Factory(e);if(s.vfs_register(t,!0),e.ccall("powersync_init_static","int",[]),this.options.encryptionKey){if(0!==e.ccall("sqlite3mc_vfs_create","int",["string","int"],[this.options.dbFilename,1]))throw new Error("Failed to create multiple cipher vfs, Database encryption will not work")}return s}registerBroadcastListeners(){this.broadcastChannel=new BroadcastChannel(`${this.options.dbFilename}-table-updates`),this.broadcastChannel.addEventListener("message",(e=>{const t=e.data;this.connectionId!=t.connectionId&&this.queueTableUpdate(t.changedTables,!1)}))}queueTableUpdate(e,t=!0){e.forEach((e=>this.updatedTables.add(e))),null==this.updateTimer&&(this.updateTimer=setTimeout((()=>this.fireUpdates(t)),0))}async init(){this._sqliteAPI=await this.openSQLiteAPI(),await this.openDB(),this.registerBroadcastListeners(),await this.executeSingleStatement(`PRAGMA temp_store = ${this.options.temporaryStorage};`),await this.executeEncryptionPragma(),this.sqliteAPI.update_hook(this.dbP,((e,t,s)=>{if(!s)return;const n=new Set([s]);this.queueTableUpdate(n)}))}async getConfig(){return this.options}fireUpdates(e=!0){this.updateTimer=null;const t={tables:[...this.updatedTables],groupedUpdates:{},rawUpdates:[]};e&&this.broadcastChannel.postMessage({changedTables:this.updatedTables,connectionId:this.connectionId}),this.updatedTables.clear(),this.iterateListeners((e=>e.tablesUpdated?.(t)))}async executeBatch(e,t){return this.acquireExecuteLock((async()=>{let s=0;try{await this.executeSingleStatement("BEGIN TRANSACTION");const n=t||[];for await(const o of this.sqliteAPI.statements(this.dbP,e)){if(null===o)return{rowsAffected:0,rows:{_array:[],length:0}};for(const e of n){for(let t=0;t<e.length;t++){const s=e[t];"boolean"==typeof s&&(e[t]=s?1:0)}t&&this.sqliteAPI.bind_collection(o,e);await this.sqliteAPI.step(o)===i.SQLITE_DONE&&(s+=this.sqliteAPI.changes(this.dbP)),this.sqliteAPI.reset(o)}}await this.executeSingleStatement("COMMIT")}catch(e){return await this.executeSingleStatement("ROLLBACK"),{rowsAffected:0,rows:{_array:[],length:0}}}return{rowsAffected:s,rows:{_array:[],length:0}}}))}async execute(e,t){return this.acquireExecuteLock((async()=>this.executeSingleStatement(e,t)))}async close(){this.broadcastChannel?.close(),await this.sqliteAPI.close(this.dbP)}async registerOnTableChange(e){return this.registerListener({tablesUpdated:t=>e(t)})}acquireExecuteLock=e=>this.statementMutex.runExclusive(e);async executeSingleStatement(e,t){const s=[];for await(const n of this.sqliteAPI.statements(this.dbP,e)){let e;const o=t?[t]:[[]];for(const a of o){a.forEach(((e,t,s)=>{"boolean"==typeof e&&(s[t]=e?1:0)})),this.sqliteAPI.reset(n),t&&this.sqliteAPI.bind_collection(n,a);const o=[];for(;await this.sqliteAPI.step(n)===i.SQLITE_ROW;){const e=this.sqliteAPI.row(n);o.push(e)}e=e??this.sqliteAPI.column_names(n),e.length&&s.push({columns:e,rows:o})}if(t)break}const n=[];for(const e of s)for(const t of e.rows){const s={};e.columns.forEach(((e,n)=>{s[e]=t[n]})),n.push(s)}return{insertId:this.sqliteAPI.last_insert_id(this.dbP),rowsAffected:this.sqliteAPI.changes(this.dbP),rows:{_array:n,length:n.length}}}}const y=new Map;let f=1;const b=async e=>(()=>{if("locks"in navigator&&navigator.locks)return navigator.locks;throw new Error("Navigator locks are not available in an insecure context. Use a secure context such as HTTPS or http://localhost.")})().request("open-wasqlite-db",(async()=>{const t=f++,{dbFilename:s}=e;if(!y.has(s)){const t=new Set,n=await(async e=>{const t=new h(e);return{init:a.proxy((()=>t.init())),getConfig:a.proxy((()=>t.getConfig())),close:a.proxy((()=>t.close())),execute:a.proxy((async(e,s)=>t.execute(e,s))),executeBatch:a.proxy((async(e,s)=>t.executeBatch(e,s))),registerOnTableChange:a.proxy((async e=>a.proxy(await t.registerOnTableChange(e))))}})(e);await n.init(),y.set(s,{clientIds:t,db:n})}const n=y.get(s);n.clientIds.add(t);const{db:o}=n,i={...o,init:a.proxy((()=>{})),close:a.proxy((()=>{const{clientIds:e}=n;if(console.debug(`Close requested from client ${t} of ${[...e]}`),e.delete(t),0==e.size)return console.debug(`Closing connection to ${s}.`),y.delete(s),o.close?.();console.debug(`Connection to ${s} not closed yet due to active clients.`)}))};return a.proxy(i)}));if("undefined"!=typeof SharedWorkerGlobalScope){self.onconnect=function(e){const t=e.ports[0];console.debug("Exposing shared db on port",t),a.expose(b,t)}}else a.expose(b);return addEventListener("unload",(()=>{Array.from(y.values()).forEach((async e=>{const{db:t}=e;t.close?.()}))})),{}})()));