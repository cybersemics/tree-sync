!function(t,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var n=e();for(var i in n)("object"==typeof exports?exports:t)[i]=n[i]}}(self,(()=>(()=>{"use strict";var t,e,n={606:t=>{t.exports=require("bson")}},i={};function r(t){var e=i[t];if(void 0!==e)return e.exports;var s=i[t]={exports:{}};return n[t](s,s.exports,r),s.exports}r.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return r.d(e,{a:e}),e},e=Object.getPrototypeOf?t=>Object.getPrototypeOf(t):t=>t.__proto__,r.t=function(n,i){if(1&i&&(n=this(n)),8&i)return n;if("object"==typeof n&&n){if(4&i&&n.__esModule)return n;if(16&i&&"function"==typeof n.then)return n}var s=Object.create(null);r.r(s);var a={};t=t||[null,e({}),e([]),e(e)];for(var o=2&i&&n;"object"==typeof o&&!~t.indexOf(o);o=e(o))Object.getOwnPropertyNames(o).forEach((t=>a[t]=()=>n[t]));return a.default=()=>n,r.d(s,a),s},r.d=(t,e)=>{for(var n in e)r.o(e,n)&&!r.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};const s=require("comlink"),a=require("@powersync/common"),o=require("async-mutex"),c=require("js-logger");var l=r.n(c);class h extends a.FetchImplementationProvider{getFetch(){return fetch.bind(globalThis)}}class u extends a.AbstractRemote{connector;logger;_bson;constructor(t,e=a.DEFAULT_REMOTE_LOGGER,n){super(t,e,{...n??{},fetchImplementation:n?.fetchImplementation??new h}),this.connector=t,this.logger=e}getUserAgent(){let t=[super.getUserAgent(),"powersync-web"];try{t.push(...function(t){t??=navigator;const e=function(t){const e=t.userAgentData?.brands;if(null!=e){const t=[{name:"Google Chrome",value:"Chrome"},{name:"Opera",value:"Opera"},{name:"Edge",value:"Edge"},{name:"Chromium",value:"Chromium"}];for(let{name:n,value:i}of t){const t=e.find((t=>t.brand==n));if(null!=t)return`${i}/${t.version}`}}const n=t.userAgent,i=[{re:/(?:firefox|fxios)\/(\d+)/i,value:"Firefox"},{re:/(?:edg|edge|edga|edgios)\/(\d+)/i,value:"Edge"},{re:/opr\/(\d+)/i,value:"Opera"},{re:/(?:chrome|chromium|crios)\/(\d+)/i,value:"Chrome"},{re:/version\/(\d+).*safari/i,value:"Safari"}];for(let{re:t,value:e}of i){const i=t.exec(n);if(null!=i)return`${e}/${i[1]}`}return null}(t),n=function(t){if(null!=t.userAgentData?.platform)return t.userAgentData.platform.toLowerCase();const e=t.userAgent,n=[{re:/windows/i,value:"windows"},{re:/android/i,value:"android"},{re:/linux/i,value:"linux"},{re:/iphone|ipad|ipod/i,value:"ios"},{re:/macintosh|mac os x/i,value:"macos"}];for(let{re:t,value:i}of n)if(t.test(e))return i;return null}(t);return[e,n].filter((t=>null!=t))}())}catch(t){this.logger.warn("Failed to get user agent info",t)}return t.join(" ")}async getBSON(){if(this._bson)return this._bson;const{BSON:t}=await Promise.resolve().then(r.t.bind(r,606,23));return this._bson=t,this._bson}}const d=()=>{if("locks"in navigator&&navigator.locks)return navigator.locks;throw new Error("Navigator locks are not available in an insecure context. Use a secure context such as HTTPS or http://localhost.")};class g extends a.AbstractStreamingSyncImplementation{constructor(t){super(t)}get webOptions(){return this.options}obtainLock(t){const e=`streaming-sync-${t.type}-${this.webOptions.identifier}`;return t.type==a.LockType.SYNC&&console.debug("requesting lock for ",e),d().request(e,{signal:t.signal},t.callback)}}class p{options;constructor(t){this.options=t}get baseConnection(){return this.options.baseConnection}init(){return this.baseConnection.init()}async shareConnection(){const{identifier:t,remote:e}=this.options;return{port:await e[s.createEndpoint](),identifier:t}}async registerOnTableChange(t){return this.baseConnection.registerOnTableChange(s.proxy(t))}async close(){await this.baseConnection.close(),this.options.remote[s.releaseProxy](),this.options.onClose?.()}execute(t,e){return this.baseConnection.execute(t,e)}executeBatch(t,e){return this.baseConnection.executeBatch(t,e)}getConfig(){return this.baseConnection.getConfig()}}class y extends a.BaseObserver{options;logger;dbGetHelpers;debugMode;_dbIdentifier;initPromise;_db=null;_disposeTableChangeListener=null;_config=null;constructor(t){if(super(),this.options=t,this._dbIdentifier=t.name,this.logger=t.logger??l().get(`LockedAsyncDatabaseAdapter - ${this._dbIdentifier}`),this.debugMode=t.debugMode??!1,this.debugMode){const t=this._execute.bind(this);this._execute=async(e,n)=>{const i=performance.now();try{const r=await t(e,n);return performance.measure(`[SQL] ${e}`,{start:i}),r}catch(t){throw performance.measure(`[SQL] [ERROR: ${t.message}] ${e}`,{start:i}),t}}}this.dbGetHelpers=this.generateDBHelpers({execute:(t,e)=>this.acquireLock((()=>this._execute(t,e)))}),this.initPromise=this._init()}get baseDB(){if(!this._db)throw new Error("Initialization has not completed yet. Cannot access base db");return this._db}get name(){return this._dbIdentifier}async init(){return this.initPromise}async _init(){this._db=await this.options.openConnection(),await this._db.init(),this._config=await this._db.getConfig(),await this.registerOnChangeListener(this._db),this.iterateListeners((t=>t.initialized?.()))}getConfiguration(){if(!this._config)throw new Error("Cannot get config before initialization is completed");return this._config}async waitForInitialized(){await this.initPromise}async shareConnection(){if(0==this._db instanceof p)throw new Error("Only worker connections can be shared");return this._db.shareConnection()}async registerOnChangeListener(t){this._disposeTableChangeListener=await t.registerOnTableChange((t=>{this.iterateListeners((e=>e.tablesUpdated?.(t)))}))}async refreshSchema(){}async execute(t,e){return this.writeLock((n=>n.execute(t,e)))}async executeBatch(t,e){return this.writeLock((n=>this._executeBatch(t,e)))}close(){this._disposeTableChangeListener?.(),this.baseDB?.close?.()}async getAll(t,e){return await this.waitForInitialized(),this.dbGetHelpers.getAll(t,e)}async getOptional(t,e){return await this.waitForInitialized(),this.dbGetHelpers.getOptional(t,e)}async get(t,e){return await this.waitForInitialized(),this.dbGetHelpers.get(t,e)}async readLock(t,e){return await this.waitForInitialized(),this.acquireLock((async()=>t(this.generateDBHelpers({execute:this._execute}))))}async writeLock(t,e){return await this.waitForInitialized(),this.acquireLock((async()=>t(this.generateDBHelpers({execute:this._execute}))))}acquireLock(t){return d().request(`db-lock-${this._dbIdentifier}`,t)}async readTransaction(t,e){return this.readLock(this.wrapTransaction(t))}writeTransaction(t,e){return this.writeLock(this.wrapTransaction(t))}generateDBHelpers(t){return{...t,async getAll(e,n){const i=await t.execute(e,n);return i.rows?._array??[]},async getOptional(e,n){const i=await t.execute(e,n);return i.rows?.item(0)??null},async get(e,n){const i=await t.execute(e,n),r=i.rows?.item(0);if(!r)throw new Error("Result set is empty");return r}}}wrapTransaction(t){return async e=>{await this._execute("BEGIN TRANSACTION");let n=!1;const i=async()=>n?{rowsAffected:0}:(n=!0,this._execute("COMMIT")),r=()=>(n=!0,this._execute("ROLLBACK"));try{const s=await t({...e,commit:i,rollback:r});return n||await i(),s}catch(t){this.logger.debug("Caught ex in transaction",t);try{await r()}catch(t){}throw t}}}_execute=async(t,e)=>{await this.waitForInitialized();const n=await this.baseDB.execute(t,e);return{...n,rows:{...n.rows,item:t=>n.rows._array[t]}}};_executeBatch=async(t,e)=>{await this.waitForInitialized();return{...await this.baseDB.executeBatch(t,e),rows:void 0}}}class w{clients;TRACE;DEBUG;INFO;TIME;WARN;ERROR;OFF;constructor(t){this.clients=t,this.TRACE=l().TRACE,this.DEBUG=l().DEBUG,this.INFO=l().INFO,this.TIME=l().TIME,this.WARN=l().WARN,this.ERROR=l().ERROR,this.OFF=l().OFF}trace(...t){console.trace(...t);const e=this.sanitizeArgs(t);this.iterateClients((t=>t.clientProvider.trace(...e)))}debug(...t){console.debug(...t);const e=this.sanitizeArgs(t);this.iterateClients((t=>t.clientProvider.debug(...e)))}info(...t){console.info(...t);const e=this.sanitizeArgs(t);this.iterateClients((t=>t.clientProvider.info(...e)))}log(...t){console.log(...t);const e=this.sanitizeArgs(t);this.iterateClients((t=>t.clientProvider.log(...e)))}warn(...t){console.warn(...t);const e=this.sanitizeArgs(t);this.iterateClients((t=>t.clientProvider.warn(...e)))}error(...t){console.error(...t);const e=this.sanitizeArgs(t);this.iterateClients((t=>t.clientProvider.error(...e)))}time(t){console.time(t),this.iterateClients((e=>e.clientProvider.time(t)))}timeEnd(t){console.timeEnd(t),this.iterateClients((e=>e.clientProvider.timeEnd(t)))}setLevel(t){}getLevel(){return l().INFO}enabledFor(t){return!0}async iterateClients(t){for(const e of this.clients)try{await t(e)}catch(t){console.error("Caught exception when iterating client",t)}}sanitizeArgs(t){return t.map((t=>{try{return structuredClone(t)}catch(t){return console.error(t),"Could not serialize log params. Check shared worker logs for more details."}}))}}var m;!function(t){t.CLOSE_CLIENT="close-client"}(m||(m={}));class f extends a.BaseObserver{ports;syncStreamClient;isInitialized;statusListener;fetchCredentialsController;uploadDataController;dbAdapter;syncParams;logger;lastConnectOptions;syncStatus;broadCastLogger;constructor(){super(),this.ports=[],this.dbAdapter=null,this.syncParams=null,this.syncStreamClient=null,this.logger=l().get("shared-sync"),this.lastConnectOptions=void 0,this.isInitialized=new Promise((t=>{const e=this.registerListener({initialized:()=>{t(),e?.()}})})),this.syncStatus=new a.SyncStatus({}),this.broadCastLogger=new w(this.ports)}async waitForStatus(t){return await this.waitForReady(),this.syncStreamClient.waitForStatus(t)}get lastSyncedAt(){return this.syncStreamClient?.lastSyncedAt}get isConnected(){return this.syncStreamClient?.isConnected??!1}async waitForReady(){return this.isInitialized}async setParams(t){this.syncParams||(this.syncParams=t,t.streamOptions?.flags?.broadcastLogs&&(this.logger=this.broadCastLogger),self.onerror=t=>{this.logger.error("Uncaught exception in PowerSync shared sync worker",t)},await this.openInternalDB(),this.iterateListeners((t=>t.initialized?.())))}async dispose(){return await this.waitForReady(),this.statusListener?.(),this.syncStreamClient?.dispose()}async connect(t){return await this.waitForReady(),d().request("shared-sync-connect",(async()=>{this.syncStreamClient=this.generateStreamingImplementation(),this.lastConnectOptions=t,this.syncStreamClient.registerListener({statusChanged:t=>{this.updateAllStatuses(t.toJSON())}}),await this.syncStreamClient.connect(t)}))}async disconnect(){return await this.waitForReady(),d().request("shared-sync-connect",(async()=>{await(this.syncStreamClient?.disconnect()),await(this.syncStreamClient?.dispose()),this.syncStreamClient=null}))}addPort(t){const e={port:t,clientProvider:s.wrap(t)};this.ports.push(e);const n=this.syncStreamClient?.syncStatus;n&&e.clientProvider.statusChanged(n.toJSON())}async removePort(t){const e=this.ports.findIndex((e=>e.port==t));if(e<0)return void console.warn(`Could not remove port ${t} since it is not present in active ports.`);const n=this.ports[e];n.db&&n.db.close(),n.clientProvider[s.releaseProxy](),this.ports.splice(e,1),[this.fetchCredentialsController,this.uploadDataController].forEach((e=>{e?.activePort.port==t&&e.controller.abort(new a.AbortOperation("Closing pending requests after client port is removed"))})),this.dbAdapter==n.db&&this.syncStreamClient&&(await this.disconnect(),await this.openInternalDB(),await this.connect(this.lastConnectOptions))}triggerCrudUpload(){this.waitForReady().then((()=>this.syncStreamClient?.triggerCrudUpload()))}async obtainLock(t){return await this.waitForReady(),this.syncStreamClient.obtainLock(t)}async hasCompletedSync(){return await this.waitForReady(),this.syncStreamClient.hasCompletedSync()}async getWriteCheckpoint(){return await this.waitForReady(),this.syncStreamClient.getWriteCheckpoint()}generateStreamingImplementation(){const t=this.syncParams;return new g({adapter:new a.SqliteBucketStorage(this.dbAdapter,new o.Mutex,this.logger),remote:new u({fetchCredentials:async()=>{const t=this.ports[this.ports.length-1];return new Promise((async(e,n)=>{const i=new AbortController;this.fetchCredentialsController={controller:i,activePort:t},i.signal.onabort=n;try{console.log("calling the last port client provider for credentials"),e(await t.clientProvider.fetchCredentials())}catch(t){n(t)}finally{this.fetchCredentialsController=void 0}}))}}),uploadCrud:async()=>{const t=this.ports[this.ports.length-1];return new Promise((async(e,n)=>{const i=new AbortController;this.uploadDataController={controller:i,activePort:t},i.signal.onabort=()=>e();try{e(await t.clientProvider.uploadCrud())}catch(t){n(t)}finally{this.uploadDataController=void 0}}))},...t.streamOptions,logger:this.logger})}async openInternalDB(){const t=this.ports[this.ports.length-1],e=await t.clientProvider.getDBWorkerPort(),n=s.wrap(e),i=this.syncParams.dbParams.dbFilename,r=await n(this.syncParams.dbParams),a=new y({name:i,openConnection:async()=>new p({remote:n,baseConnection:r,identifier:i}),logger:this.logger});await a.init(),this.dbAdapter=t.db=a}updateAllStatuses(t){this.syncStatus=new a.SyncStatus(t),this.ports.forEach((e=>e.clientProvider.statusChanged(t)))}_testUpdateAllStatuses(t){this.syncStreamClient||(this.syncStreamClient=this.generateStreamingImplementation()),this.syncStreamClient.syncStatus=new a.SyncStatus(t),this.updateAllStatuses(t)}}const b=self;l().useDefaults();const C=new f;return b.onconnect=function(t){const e=t.ports[0];e.addEventListener("message",(t=>{const n=t.data;n?.event==m.CLOSE_CLIENT&&(console.log("closing shared for port",e),C.removePort(e))})),s.expose(C,e),C.addPort(e)},{}})()));